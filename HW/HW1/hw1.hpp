#pragma once

/* THE FOLLOWING HAS BEEN AUTOMATICALLY GENERATED BY THE EGG PARSER GENERATOR.
 * DO NOT EDIT. */

// {%

#include "symtab.hpp"

// %}

#include <string>
#include "parser.hpp"

namespace hw1 {

	bool assn(parser::state&, entry &);
	bool expr(parser::state&, entry &);
	bool atom(parser::state&, entry &);
	bool name(parser::state&, string &);
	bool int_val(parser::state&, int &);
	bool bool_val(parser::state&, int &);
	bool eq_less(parser::state&, int &);
	bool add_sub(parser::state&, int &);
	bool mult(parser::state&, int &);
	bool expo(parser::state&, int &);
	bool SET(parser::state&);
	bool TRUE(parser::state&);
	bool FALSE(parser::state&);
	bool CARET(parser::state&);
	bool EQ(parser::state&);
	bool LESSTHAN(parser::state&);
	bool STAR(parser::state&);
	bool PLUS(parser::state&);
	bool MINUS(parser::state&);
	bool _(parser::state&);

	bool assn(parser::state& ps, entry & psVal) {
		entry  e;
		string  n;

		return parser::memoize(1, psVal, parser::named("assignment", 
			parser::choice({
				
					parser::sequence({
						parser::bind(n, name),
						_,
						SET,
						_,
						parser::bind(e, expr),
						[&](parser::state& ps) { psVal = entry{n, e.ty, e.val};  return true; }}),
				
					parser::sequence({
						parser::bind(e, expr),
						[&](parser::state& ps) { psVal = entry{"", e.ty, e.val};  return true; }})})))(ps);
	}

	bool expr(parser::state& ps, entry & psVal) {
		int  v;

		return parser::memoize(2, psVal, parser::named("expression", 
			parser::choice({
				
					parser::sequence({
						parser::bind(v, eq_less),
						[&](parser::state& ps) { psVal = entry{BOOL, v};  return true; }}),
				
					parser::sequence({
						parser::bind(v, add_sub),
						[&](parser::state& ps) { psVal = entry{INT, v};  return true; }})})))(ps);
	}

	bool atom(parser::state& ps, entry & psVal) {
		string  n;
		int  v;

		return parser::memoize(3, psVal, parser::named("atom", 
			parser::choice({
				
					parser::sequence({
						parser::bind(n, name),
						[&](parser::state& ps) {
            check_not_equal( global_symtab[n].ty, ERR, "invalid variable " + n );
            psVal = global_symtab[n];
         return true; }}),
				
					parser::sequence({
						parser::bind(v, int_val),
						[&](parser::state& ps) { psVal = entry{INT, v};  return true; }})})))(ps);
	}

	bool name(parser::state& ps, string & psVal) {
		return parser::memoize(4, psVal, parser::named("name", 
			parser::sequence({
				parser::look_not(parser::unbind(bool_val)),
				parser::capture(psVal, parser::memoize_some(5, 
					parser::choice({
						parser::between('A', 'Z'),
						parser::between('a', 'z'),
						parser::literal('_')}))),
				_})))(ps);
	}

	bool int_val(parser::state& ps, int & psVal) {
		std::string s;

		return parser::memoize(6, psVal, parser::named("integer value", 
			parser::sequence({
				_,
				parser::capture(s, parser::memoize_some(7, parser::between('0', '9'))),
				_,
				[&](parser::state& ps) { psVal = stoi(s);  return true; }})))(ps);
	}

	bool bool_val(parser::state& ps, int & psVal) {
		std::string s;

		return parser::memoize(8, psVal, parser::named("boolean value", 
			parser::sequence({
				_,
				parser::capture(s, 
					parser::choice({
						TRUE,
						FALSE})),
				_,
				[&](parser::state& ps) {
        if (s.compare("true") == 0) {
            psVal = 1;
        }
        else if (s.compare("false") == 0) {
            psVal = 0;
        }
      return true; }})))(ps);
	}

	bool eq_less(parser::state& ps, int & psVal) {
		entry  a;
		entry  b;
		int  c;
		int  d;
		int  v;
		int  x;
		int  y;

		return parser::memoize(9, psVal, parser::named("boolean value", 
			parser::choice({
				
					parser::sequence({
						parser::bind(a, atom),
						_,
						EQ,
						_,
						parser::bind(b, atom),
						[&](parser::state& ps) {psVal = (a.val==b.val); return true; }}),
				
					parser::sequence({
						parser::bind(c, bool_val),
						_,
						EQ,
						_,
						parser::bind(d, bool_val),
						[&](parser::state& ps) {psVal = (c==d); return true; }}),
				
					parser::sequence({
						parser::bind(v, bool_val),
						[&](parser::state& ps) { psVal = v;  return true; }}),
				
					parser::sequence({
						parser::bind(x, int_val),
						_,
						LESSTHAN,
						_,
						parser::bind(y, int_val),
						[&](parser::state& ps) {psVal = (x<y); return true; }})})))(ps);
	}

	bool add_sub(parser::state& ps, int & psVal) {
		int  b;

		return parser::memoize(10, psVal, parser::named("integer value", 
			parser::choice({
				
					parser::sequence({
						parser::bind(psVal, mult),
						_,
						parser::many(
							parser::sequence({
								PLUS,
								_,
								parser::bind(b, mult),
								[&](parser::state& ps) {psVal += b; return true; }}))}),
				
					parser::sequence({
						parser::bind(psVal, mult),
						_,
						parser::many(
							parser::sequence({
								MINUS,
								_,
								parser::bind(b, mult),
								[&](parser::state& ps) {psVal -= b; return true; }}))})})))(ps);
	}

	bool mult(parser::state& ps, int & psVal) {
		int  x;

		return parser::memoize(11, psVal, parser::named("integer value", 
			parser::sequence({
				parser::bind(psVal, expo),
				_,
				parser::many(
					parser::sequence({
						STAR,
						_,
						parser::bind(x, expo),
						[&](parser::state& ps) { psVal *= x; return true; }}))})))(ps);
	}

	bool expo(parser::state& ps, int & psVal) {
		entry  a;
		entry  b;
		entry  x;

		return parser::memoize(12, psVal, parser::named("integer value", 
			parser::choice({
				
					parser::sequence({
						parser::bind(a, atom),
						_,
						CARET,
						_,
						parser::bind(b, atom),
						[&](parser::state& ps) {psVal = pow(a.val,b.val); return true; }}),
				
					parser::sequence({
						parser::bind(x, atom),
						[&](parser::state& ps) {psVal = x.val; return true; }})})))(ps);
	}

	bool SET(parser::state& ps) {
		return parser::memoize(13, 
			parser::sequence({
				parser::named("\":=\"", parser::literal(":=")),
				_}))(ps);
	}

	bool TRUE(parser::state& ps) {
		return parser::memoize(14, parser::literal("true"))(ps);
	}

	bool FALSE(parser::state& ps) {
		return parser::memoize(15, parser::literal("false"))(ps);
	}

	bool CARET(parser::state& ps) {
		return parser::memoize(16, parser::literal("^"))(ps);
	}

	bool EQ(parser::state& ps) {
		return parser::memoize(17, parser::literal("=="))(ps);
	}

	bool LESSTHAN(parser::state& ps) {
		return parser::memoize(18, parser::literal("<"))(ps);
	}

	bool STAR(parser::state& ps) {
		return parser::memoize(19, parser::literal("*"))(ps);
	}

	bool PLUS(parser::state& ps) {
		return parser::memoize(20, parser::literal("+"))(ps);
	}

	bool MINUS(parser::state& ps) {
		return parser::memoize(21, parser::literal("-"))(ps);
	}

	bool _(parser::state& ps) {
		return parser::memoize(22, parser::memoize_many(23, 
			parser::choice({
				parser::literal(' '),
				parser::literal('\t'),
				parser::literal('\r'),
				parser::literal('\n')})))(ps);
	}

} // namespace hw1

