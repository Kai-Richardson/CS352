#pragma once

/* THE FOLLOWING HAS BEEN AUTOMATICALLY GENERATED BY THE EGG PARSER GENERATOR.
 * DO NOT EDIT. */

// {%

#include "parse_tree.hpp"

// %}

#include <string>
#include "parser.hpp"

namespace iftree {

	bool IfStmt(parser::state&, parse_tree &);
	bool Expr(parser::state&, parse_tree &);
	bool AddExpr(parser::state&, parse_tree &);
	bool AtomExpr(parser::state&, parse_tree &);
	bool Stmt(parser::state&, parse_tree &);
	bool keyword(parser::state&);
	bool WORD(parser::state&, parse_tree &);
	bool ASSN(parser::state&, parse_tree &);
	bool PLUS(parser::state&, parse_tree &);
	bool IF(parser::state&, parse_tree &);
	bool ELSE(parser::state&, parse_tree &);
	bool OPEN(parser::state&, parse_tree &);
	bool CLOSE(parser::state&, parse_tree &);
	bool _(parser::state&);

	bool IfStmt(parser::state& ps, parse_tree & psVal) {
		parse_tree  a;
		parse_tree  b;
		parse_tree  c;
		parse_tree  d;
		parse_tree  e;
		parse_tree  f;
		parse_tree  g;

		return parser::memoize(1, psVal, 
			parser::sequence({
				parser::bind(a, IF),
				parser::bind(b, OPEN),
				parser::bind(c, Expr),
				parser::bind(d, CLOSE),
				parser::bind(e, Stmt),
				[&](parser::state& ps) { psVal= parse_tree{"IfStmt", {a,b,c,d,e}};  return true; },
				parser::option(
					parser::sequence({
						parser::bind(f, ELSE),
						parser::bind(g, Stmt),
						[&](parser::state& ps) { psVal += f; psVal += g;  return true; }}))}))(ps);
	}

	bool Expr(parser::state& ps, parse_tree & psVal) {
		parse_tree  e;
		parse_tree  op;
		parse_tree  var;

		return parser::memoize(2, psVal, 
			parser::choice({
				
					parser::sequence({
						parser::bind(var, WORD),
						parser::bind(op, ASSN),
						parser::bind(e, Expr),
						[&](parser::state& ps) { psVal = parse_tree{"Expr", {var, op, e}};  return true; }}),
				parser::bind(psVal, AddExpr)}))(ps);
	}

	bool AddExpr(parser::state& ps, parse_tree & psVal) {
		parse_tree  b;
		parse_tree  op;

		return parser::memoize(3, psVal, 
			parser::sequence({
				parser::bind(psVal, AtomExpr),
				parser::many(
					parser::sequence({
						parser::bind(op, PLUS),
						parser::bind(b, AtomExpr),
						[&](parser::state& ps) { psVal = parse_tree{"Expr", {op, b}};  return true; }}))}))(ps);
	}

	bool AtomExpr(parser::state& ps, parse_tree & psVal) {
		std::string s;

		return parser::memoize(4, psVal, 
			parser::sequence({
				parser::capture(s, parser::memoize_some(5, parser::between('0', '9'))),
				_,
				[&](parser::state& ps) { psVal = parse_tree{"Expr", {parse_tree{"\"" + s + "\""}}};  return true; }}))(ps);
	}

	bool Stmt(parser::state& ps, parse_tree & psVal) {
		parse_tree  w;

		return parser::memoize(6, psVal, 
			parser::sequence({
				parser::bind(w, WORD),
				[&](parser::state& ps) { psVal = parse_tree{"Stmt", {w}};  return true; },
				parser::many(
					parser::sequence({
						_,
						parser::bind(w, WORD),
						[&](parser::state& ps) { psVal += w;  return true; }})),
				_}))(ps);
	}

	bool keyword(parser::state& ps) {
		return parser::memoize(7, 
			parser::choice({
				parser::unbind(IF),
				parser::unbind(ELSE)}))(ps);
	}

	bool WORD(parser::state& ps, parse_tree & psVal) {
		std::string s;

		return parser::memoize(8, psVal, 
			parser::sequence({
				parser::look_not(keyword),
				parser::capture(s, parser::memoize_some(9, 
					parser::choice({
						parser::between('A', 'Z'),
						parser::between('a', 'z'),
						parser::literal('_')}))),
				_,
				[&](parser::state& ps) {psVal = parse_tree{"\"" + s + "\""};  return true; }}))(ps);
	}

	bool ASSN(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(10, psVal, 
			parser::sequence({
				parser::literal("="),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\"=\""};  return true; }}))(ps);
	}

	bool PLUS(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(11, psVal, 
			parser::sequence({
				parser::literal("+"),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\"+\""};  return true; }}))(ps);
	}

	bool IF(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(12, psVal, 
			parser::sequence({
				parser::literal("if"),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\"if\""};  return true; }}))(ps);
	}

	bool ELSE(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(13, psVal, 
			parser::sequence({
				parser::literal("else"),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\"else\""};  return true; }}))(ps);
	}

	bool OPEN(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(14, psVal, 
			parser::sequence({
				parser::literal("("),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\"(\""};  return true; }}))(ps);
	}

	bool CLOSE(parser::state& ps, parse_tree & psVal) {
		return parser::memoize(15, psVal, 
			parser::sequence({
				parser::literal(")"),
				_,
				[&](parser::state& ps) {  psVal = parse_tree{"\")\""};  return true; }}))(ps);
	}

	bool _(parser::state& ps) {
		return parser::memoize(16, parser::memoize_many(17, 
			parser::choice({
				parser::literal(' '),
				parser::literal('\t'),
				parser::literal('\r'),
				parser::literal('\n')})))(ps);
	}

} // namespace iftree

