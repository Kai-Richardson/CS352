#pragma once

/* THE FOLLOWING HAS BEEN AUTOMATICALLY GENERATED BY THE EGG PARSER GENERATOR.
 * DO NOT EDIT. */

// {%

//#include <stdio.h>

// %}

#include <string>
#include "parser.hpp"

namespace calc {

	bool expr(parser::state&, double &);
	bool eql_neq(parser::state&, double &);
	bool add_sub(parser::state&, double &);
	bool mul_div(parser::state&, double &);
	bool num(parser::state&, double &);
	bool multiply(parser::state&, double &);
	bool divide(parser::state&, double &);
	bool add(parser::state&, double &);
	bool subtract(parser::state&, double &);
	bool equals(parser::state&, double &);
	bool doesnotequal(parser::state&, double &);
	bool MULT(parser::state&);
	bool DIV(parser::state&);
	bool PLUS(parser::state&);
	bool MINU(parser::state&);
	bool ISEQ(parser::state&);
	bool NOEQ(parser::state&);
	bool _(parser::state&);

	bool expr(parser::state& ps, double & psVal) {
		return parser::memoize(1, psVal, 
			parser::sequence({
				parser::bind(psVal, eql_neq),
				parser::look_not(parser::any())}))(ps);
	}

	bool eql_neq(parser::state& ps, double & psVal) {
		return parser::memoize(2, psVal, 
			parser::sequence({
				
					parser::choice({
						parser::bind(psVal, add_sub),
						parser::bind(psVal, equals),
						parser::bind(psVal, doesnotequal)}),
				parser::look_not(parser::any())}))(ps);
	}

	bool add_sub(parser::state& ps, double & psVal) {
		return parser::memoize(3, psVal, 
			parser::sequence({
				
					parser::choice({
						parser::bind(psVal, mul_div),
						parser::bind(psVal, add),
						parser::bind(psVal, subtract)}),
				parser::look_not(parser::any())}))(ps);
	}

	bool mul_div(parser::state& ps, double & psVal) {
		return parser::memoize(4, psVal, 
			parser::sequence({
				
					parser::choice({
						parser::bind(psVal, multiply),
						parser::bind(psVal, divide),
						parser::bind(psVal, num)}),
				parser::look_not(parser::any())}))(ps);
	}

	bool num(parser::state& ps, double & psVal) {
		std::string s;

		return parser::memoize(5, psVal, 
			parser::sequence({
				parser::capture(s, 
					parser::choice({
						
							parser::sequence({
								parser::memoize_some(6, parser::between('0', '9')),
								parser::option(
									parser::sequence({
										parser::literal('.'),
										parser::memoize_many(7, parser::between('0', '9'))}))}),
						
							parser::sequence({
								parser::literal('.'),
								parser::memoize_some(8, parser::between('0', '9'))})})),
				_,
				[&](parser::state& ps) { psVal = std::stod(s);  return true; }}))(ps);
	}

	bool multiply(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(9, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						MULT,
						parser::capture(b, 
							parser::choice({
								parser::unbind(multiply),
								parser::unbind(num)}))}),
				parser::look_not(parser::any()),
				[&](parser::state& ps) { psVal = std::stod(a)*std::stod(b);  return true; }}))(ps);
	}

	bool divide(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(10, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						DIV,
						parser::capture(b, parser::unbind(num))}),
				parser::look_not(parser::any()),
				[&](parser::state& ps) { psVal = std::stod(a)/std::stod(b);  return true; }}))(ps);
	}

	bool add(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(11, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						PLUS,
						parser::capture(b, parser::unbind(num))}),
				parser::look_not(parser::any()),
				[&](parser::state& ps) { psVal = std::stod(a)+std::stod(b);  return true; }}))(ps);
	}

	bool subtract(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(12, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						parser::many(
							parser::sequence({
								MINU,
								parser::capture(b, parser::unbind(num)),
								[&](parser::state& ps) { psVal = std::stod(a)-std::stod(b);  return true; }}))}),
				parser::look_not(parser::any())}))(ps);
	}

	bool equals(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(13, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						ISEQ,
						parser::capture(b, parser::unbind(num))}),
				parser::look_not(parser::any()),
				[&](parser::state& ps) { psVal = std::stod(a)==std::stod(b);  return true; }}))(ps);
	}

	bool doesnotequal(parser::state& ps, double & psVal) {
		std::string a;
		std::string b;

		return parser::memoize(14, psVal, 
			parser::sequence({
				
					parser::sequence({
						parser::capture(a, parser::unbind(num)),
						NOEQ,
						parser::capture(b, parser::unbind(num))}),
				parser::look_not(parser::any()),
				[&](parser::state& ps) { psVal = std::stod(a)!=std::stod(b);  return true; }}))(ps);
	}

	bool MULT(parser::state& ps) {
		return parser::memoize(15, 
			parser::sequence({
				parser::literal("*"),
				_}))(ps);
	}

	bool DIV(parser::state& ps) {
		return parser::memoize(16, 
			parser::sequence({
				parser::literal("/"),
				_}))(ps);
	}

	bool PLUS(parser::state& ps) {
		return parser::memoize(17, 
			parser::sequence({
				parser::literal("+"),
				_}))(ps);
	}

	bool MINU(parser::state& ps) {
		return parser::memoize(18, 
			parser::sequence({
				parser::literal("-"),
				_}))(ps);
	}

	bool ISEQ(parser::state& ps) {
		return parser::memoize(19, 
			parser::sequence({
				parser::literal("=="),
				_}))(ps);
	}

	bool NOEQ(parser::state& ps) {
		return parser::memoize(20, 
			parser::sequence({
				parser::literal("!="),
				_}))(ps);
	}

	bool _(parser::state& ps) {
		return parser::memoize(21, parser::memoize_many(22, 
			parser::choice({
				parser::literal(' '),
				parser::literal('\t'),
				parser::literal('\r'),
				parser::literal('\n')})))(ps);
	}

} // namespace calc

